这是一个Paxos协议的实现。下文描述了paxos协议逐步完善的过程。

# 1. 单法令神会

paxos岛的居民每年举行一次神会，神会的牧师全部到场，然后他们以某种方式通过一条法令作为法律条文，会议全程没有秘书负责记录会议结果，只有每个牧师人手一本律薄，一旦法令通过，他们会把法令记录在律簿上，不能修改和擦除。

会议有两个要求：

1. 必须有且只有一条法令通过。
2. 牧师手中的律薄内容必须一致，且不允许篡改。（对于任意两个律薄`L1`和`L2`来说，其中一个律薄可能在某个位置存在空白，但是不能出现在某个相同位置存在不同的内容）

随着商业的发展，神会的牧师开始在会议期间进进出出，因为牧师没有到齐，神会无法选出一个法令，现在需要形成一个新的议会协议可以帮助处理这种情况。

# 2. 新的协议

简单来说整个议会相当于一个分布式集群，集群中的每个节点都有自己的状态，需要实现一个允许集群节点故障并能保证集群节点状态一致的协议。
> 客户端可以向集群请求保存一些数据，即使集群中有节点崩溃，客户端通过集群读取到的数据依然是完整且一致的。

因为集群中的节点可能随时崩溃并在后续某个时刻恢复，为了使崩溃的节点能够恢复到和其他节点一致，可以对节点的状态变化编号（1,2,3...）并记录成日志，当节点从崩溃中恢复后,日志可用于恢复其缺失的状态变化。

对于一个集群`c`，假设集群中的节点编号为`n-1`,`n-2`,`n-3`，一个最简单的集群状态一致的办法是预先设定一个主节点`n-master`，`n-master`负责整个集群的同步，来自客户端的请求到达`n-master`，由`n-master`处理请求，产生状态日志，向其他节点发起同步，等待整个集群的节点同步完全，最后整个集群的状态将是一致的。但是一旦`n-master`崩溃，整个集群将变得不可用，可以设计一种主节点切换的协议来保证集群的可用，但是这个新的`n-master`需要得到集群中其他节点的一致认定，需要完成和上述类似的同步过程，又回到了状态一致的问题。


1. 我们**允许集群中的每个节点都可以处理请求，并发起同步**（这避免了固定一个主节点负责同步时主节点崩溃会导致整个集群不可用的问题）。

2. 假设有三个请求`request0(set s=0)`, `request1(set s=1)`, `request2(set s=2)`被发起并分散到三个节点上，它们的日志长度均为0，这三个节点分别处理请求(执行`set s=x`并把指令附加在日志`0`处)，这时三个节点的日志出现了不一致，可以设置一个先决条件，对于给定的日志位置`p(position)`，必须有且只有一个节点可以写入。可以要求节点在将状态日志记入位置`p`之前必须先从所有节点中胜出，节点可以向其他节点发起请求以赢得在`p`处写入日志的机会。如果要求请求必须获得所有节点的通过(`accept`)，那么集群将不容许任何节点崩溃，如果要求通过的节点数量小于或等于节点总数的1/2，则可能会出现两个请求被两组不同的节点分别通过的情况，要求过半节点通过既可以保证只有一个节点胜出，又能容许最多的节点崩溃。

3. 如果客户端只产生了一个请求，这个请求仍应当被处理并同步到整个集群，所以，对于日志位置`p`节点应当通过它接收到的第一个请求。

4. 对于`p`，如果只允许节点通过一次请求，那么很容易就能实现胜出的逻辑。但是考虑到多个请求会被同时发起，集群中的节点可能会分别通过这些请求，并且通过的分组节点数量都不满足过半的要求，此时`p`处将不会记录日志。后续来自客户端的请求仍将被附加在`p`处，但是由于：`对于p，只允许节点通过一次请求`的限制，这些请求都无法获得通过，集群将无法正常工作。所以，**允许节点多次通过同一日志位置的请求**。

5. 对于`position(p)`，如果两个通过请求被先后发起，那么两个请求可能会被过半节点先后通过，同样存在同一位置多个不同记录的问题。如果要求一个请求胜出（获得过半通过）了，那么**后续允许通过的请求也必须与已经胜出的内容相同**，这个问题就可以解决。一个节点只知道自己通过的情况，不能确定某个请求是否已经被过半数通过，考虑到已经胜出的请求必定已经获得过半节点中的至少一个节点的通过（通过条件要求的过半节点和任意过半节点之间必定有重叠），所以可以要求对于`p`发起同步请求前应当先与过半数节点通讯，获取过半节点在`p`处的通过情况，依此来判断集群节点`p`处的日志记录情况。

6. 对于`p`，如果不存在已通过的记录，那么节点可以自由的发起通过请求，假设`n1` `n2`分别发起了`(s=1)@p`和`(s=2)@p`请求，可能`(s=2)@p`先在集群中完成了过半通过，此时如果继续通过`(s=1)@p`，那么集群中的节点在`p`处出现了两个不同的内容。所以，节点在通过请求时需要确保从请求发起到被通过之间没有新的请求被发起，可以为每个请求设置唯一编号`seqNumber`，在发起通过请求之前，节点查询`p`处的通过情况时，请求携带`seqNumber`，其他节点保存`seqNumber`，如果通过请求接收到的`seqNumber`和之前保存的`seqNumber`一致则说明没有新的请求被发起，可以安全的通过，否则说明一个新的通过请求已经被发起了，请求内容可能和即将要通过的内容不一致，因此不能继续通过。

7. 唯一编号的生成可以采用整个集群都记录的策略，节点产生递增编号，然后尝试请求保存到整个集群的所有节点，如果当前编号大于节点上次保存的编号，则说明这是一个新的递增的编号，可以顺利保存，否则保存失败，重新生成。这里依然采用保存过半节点的方式来允许节点崩溃。

8. 对于`p`，由于节点的崩溃，集群中的节点可能分别通过了`seq1#request1(set s=1)@p`，`seq2#request2(set s=2)@p`，`seq3#request3(set s=3)@p`，因为`(5)`的要求，可以确定较小`seq`的请求必定未获得过半的通过，而最大的`seq`可能已经获得通过，并且同步到了一个或者多个节点。于是完善`(4)`：**允许节点多次通过同一日志位置的请求，但是要求新通过的请求的编号要大于最近一次通过的请求的编号**。

9. 对于已经在`p`处获得半数通过的请求来说，`(5)`中先查询后发起，`(6)`中的避免并发发起可以保证把请求写入日志`p`处是安全的。节点在获得过半通过响应后，先写入日志，接着通知其他节点完成相同的操作。



于是，一个简单的同步协议如下：

1. 集群中的节点都负责维护一些文件来记录：

	①自己上次发起的通过请求的编号`lastTried`（用于递增产生唯一序号）。
	
	②自己接收到的通过请求的最大编号`nextBal`（用于判断是否有请求在并发发起）。
	
	③自己最近一次通过的请求`preVote`（用于集群故障恢复后恢复已经获得过半通过但未能完成同步的请求）。
	
	④已经获得通过的请求序列（日志）（记录已经同步成功的请求，用于集群节点日志同步）。

2. 客户端`c`开始向集群中的一个节点`n-x`发送请求，`n-x`递增并保存`lastTried`的值为`b(lastTried + 1)`,然后携带日志的下个位置`p`（要同步的日志位置）向过半节点发起请求`NextBallot(b,p)`来确定唯一编号。

3. 其他节点接收`NextBallot(b,p)`，判断`b`和自身记录的`_b(nextBal)`的大小（更大说明这是新的编号，安全返回），和自身下个日志位置`_p`和`p`的大小（更大的`p`说明日志`p`处空白，可以通过请求），如果`b > _b` 并且 `p > _p` 则说明编号`b`和位置`p`是安全的，节点保存`b`到`nextBal`并返回`LastVote(b,preVote)`给`n-x`，否则节点返回自身的`_b`或者日志`p -> _p`处的内容供`n-x`同步状态。

4. 如果`n-x`获得过半节点的`LastVote(b,preVote)`响应，则说明它可以发起`BeginBallot(b,d,p)`来请求通过了，其中`d(decree)`应当是接收到的`LastVote`中编号最大并且位置为`p`的表决的内容，如果`d`为空，`n-x`可以使用客户端`c`的请求作为`d`。

5. 其他节点接收`n-x`的请求`BeginBallot(b,d)`，判断`b`和自己保存的`nextBal`是否相同，相同则表示没有更新的请求在发起，可以安全通过，并且记录`preVote`。

6. `n-x`获取过半节点的通过，可以安全的把`d`附加在日志`p`处，接着它发送`Success(d)`给集群中其他节点，其他节点接收请求，将`d`记录在日志上。（`d`应当携带`p`的信息，因为集群中可能有新节点加入，如果简单的附加`d`到日志末尾，可能会写入到不同的位置）



# 2. 选择一个总统
考虑到`步骤3和5`，如果多个更大`seq`的请求被频繁发起，那么可能永远也没有请求被通过，可以选择一个总统，由这个总统来作为唯一的发起人。

> paxos论文描述的选举总统的方式比较简略，通过上述6个步骤，也可以实现总统的选举，只需要消除频繁发起`seq`请求造成相互冲突的问题即可。
> 1. 节点`n`先请求尝试获取一个最新的编号，节点返回自己通过的最大表决编号的同时，返回自己的状态。
> 2. `n`先尝试修正自己的请求编号，在自身编号大于其他节点已经投过通过票的最大表决编号之后，再判断过半节点的节点状态，如果这些节点均为`选举总统中`状态，则说明现在选举是安全的，否则可能已经存在一个总统正在和过半节点同步，只需要休息一段时间重试即可，在重试期间，如果收到总统的消息，则可以据此改变自身状态。
> 3. 如果过半节点都在`选举总统中`状态，那么可以把这些节点中id编号最大的节点作为总统，发起表决。

考虑到`选举步骤2`会出现频繁发起的问题，我们可以在`步骤3`**未能获得过半节点通过的情况下，随机休眠一段时间**，然后再发起下一轮总统表决。

# 3. 持续通过多条法令

假设我们通过`第2节`选择了一个总统，总统和部分节点组成了一个过半的集合，总统通过询问得知集合节点最近一次通过的法令，并把这个法令重新通过并记录在所有节点的日志文件上，这样一条法令就被通过了。如果需要通过更多的法令，总统将不再需要询问下一轮表决的编号，因为他上次发起的编号就是满足条件的，他可以直接递增编号，继续发起表决，等议会中过半议员选择通过，他在律簿上记录新的一条法令，并且告知所有人。

# 4. 新的总统选举制度

## 4.1. 律薄足够新的总统
考虑到议员`e`的编号足够大，但是它可能长时间都不在议会之中，他的律薄可能是空白的，在它出任总统之后，可能还需要附带律薄索引位置的询问，来逐步完善自己的律簿内容到最新，然后才能确定自己新发起的表决的法令在律薄中的索引，并且他还要负责帮助完善其他人的律薄。

选择律薄长度最长的议员作为总统是个好选择，于是修正`第2节`中的选举策略来完善这个制度，在选择总统时可以发起请求，获取过半议员的`律薄长度和姓名`，然后通过排序，选出律薄最长的那一位，进行总统的表决和选定。

## 4.2. 总统的续期和离任
考虑到总统可能在某个时刻离开议会，所以，在通过总统选择法令时，最好携带上总统的任期结束时间，在这个总统任期结束之后，如果他没有通过新的法令完成续期，那么其他议员可以发起新一轮的选举。为了消除各个议员时钟的误差，可以设定总统的任期为`10s`，通讯存在延迟，但是这个延迟的时间是可控的，可能法令表明`a`在标准时间`t`成为总统，但是`b`在`t+3`之后才收到消息，那么如果`b`在`t+3`+`10s`时还没有收到续期的消息，他就可以认为总统已经离开了，他可以发起新一轮的总统表决。

> paxos论文中采取的方式是：容许部分时钟误差。假设时钟误差在15分钟，那么可以在总统任期到期的时间`t`+15分再开始发起总统选举。

## 4.3. 消除总统冲突
一个总统离开了，那么剩下的议员应当重新选择新的总统，假设总统`a`离开了，然后选择了新总统`b`，那么等`a`再次回到议会厅，可能仍旧认为自己是总统，然后和`b`开始重复发起表决影响议会的进行。

可以考虑总统的任职也类似一个长律薄，产生新的总统后，新的总统总是记录在律薄的最新的一条，依次对应任期：1,2,3... 

当一个节点发起总统选举时，他需要确认过半节点的状态，如果过半节点都处于`选举总统`状态中，则说明他们最近一轮投票通过的任期的总统可能消失了。可以发起新的总统表决，新的任期为：`最近一轮通过的总统表决任期+1`。

通过在表决中携带任期编号可以区分新旧总统，一旦新总统选举通过，旧的总统发起的携带旧任期的表决将会被拒绝。

# 5. 议会成员的变更

可以把议会成员集合变更当做法令的一部分，需要修改议会成员时，可以发起一轮表决，然后提交后生效。


# 6. 长律薄和法律书

律薄记录了所有的法令，但是记录的内容越来越长，需要查找其中的内容并不容易，假设对谋条法律条文反复进行了修改，那么只有最后一条是有效的，所以，可以通过定期的归纳，把法令内容转换成法律书，可以有效的缩短律薄的长度，同时律薄要遗留一部分法令条文。对于律薄内容缺失较少的议员只需要学习少量的法令即可完成同步，对于律薄内容缺失较多的议员，可以直接学习整本法律书。


# 7. 分布式共识算法的实现

议员=进程。

表决=请求进程保存的内容。

律薄=存储通过的请求内容的日志文件。

法律书=请求最后应用产生的状态。（比如：一系列对于节点的操作形成了zookeeper的database，保存了节点信息）




